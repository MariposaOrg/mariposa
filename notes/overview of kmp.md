# Introduction
The kotlin multiplatorm (KMP) library provides a framework for the development of
cross platform libraries and UI. KMP targets Android, IOS, Desktop (native kotlin), 
and web (WASM). Most kotlin projects KMP uses the Gradle build system. By using a 
set of build rules KMP is able to use one codebase across several targets. Gradle is 
equivilent to Cargo for rust, or a smarter Cmake for c++.

# Basic structure of a gradle project.

```
project root
├── .gradle - project-specific cache directory generated by gradle.
├── build - the build directory of this project into which gradle generates all build artifacts.
├── gradle
│   └── wrapper - contains the jar file and configuration of the gradle wrapper.
├── gradle.properties - project-specific gradle configuration properties.
├── gradlew - scripts for executing builds using the gradle wrapper.
├── gradlew.bat 
├── settings.gradle.kts - the project’s settings file where the list of subprojects is defined.
├── subproject-one  
|   └── build.gradle.kts - usually, a project is organized into one or multiple subprojects.
├── subproject-two  
|   └── build.gradle.kts - each subproject has its own gradle build script.
└── ⋮
```
For proper versioning the gradle CLI utility can generate a "Graddle wrapper".
This used to call a specifc version of gradle. If the requested version is not
present on the host machine it will be downloaded and stored in ".gradle".

# Basic structure of a KMP project
```
project root
├── build
├── build.gradle.kts
├── composeApp - Main project
│   ├── build
│   ├── build.gradle.kts
│   └── src 
│       ├── androidMain
│       ├── commonMain - Location of shared code
│       ├── desktopMain
│       └── iosMain
├── gradle (.gradle in previous example)
├── gradle.properties
├── gradlew
├── gradlew.bat
├── iosApp - Directory used for managing xcode build settings
├── LICENSE
├── local.properties
├── notes
├── README.md
└── settings.gradle.kts
```
the main project is stored in "composeApp". Here there is a sub directory
for each targets platform specific code and a common folder. Most if not
all code should be in common main. The target specific source files
are reserved for calling the UI / modules from common source.

# KMP Compose
KMP compose is an extention of JetPack Compose, a declerative UI framework.
Traditionally UI is often designed using a markup language which is "inflated"
into a graphical UI. Each widget ussually having its own scope and memory space.
With JetPack compose UI is defined in Kotlin using "composable" functions.

#### Weird kotlin syntatic sugar
Kotlin has a kind of lambda called a "trailing lambda". If a function decleration
takes a lambda as its last parameter, the lambda can be defined outside of the function
call. JetPack Compose uses these extensively. For example.

``` kotlin

// Function that takes only a lambda parameter
fun doSomething(action: () -> Unit) {
    action()
}

// Function with just a lambda parameter that takes a string
fun processText(transform: (String) -> String) {
    val result = transform("hello world")
    println(result)
}

fun main() {
    // No parentheses needed when calling with just a lambda
    doSomething {
        println("Hello!")
    }
    
    // Also no parentheses needed here
    processText { text ->
        text.uppercase()
    }
    
    // Using 'it' with omitted parentheses
    processText {
        it.uppercase()
    }
}  
```

Below is an example of a UI definition for a basic KMP compose app.


``` kotlin

@Composable
@Preview
fun App() {
    MaterialTheme {
        var showContent by remember { mutableStateOf(false) }
        Column(Modifier.fillMaxWidth(), horizontalAlignment = Alignment.CenterHorizontally) {
            Button(onClick = { showContent = !showContent }) {
                Text("Click me!")
            }
            AnimatedVisibility(showContent) {
                val greeting = remember { Greeting().greet() }
                Column(Modifier.fillMaxWidth(), horizontalAlignment = Alignment.CenterHorizontally) {
                    Image(painterResource(Res.drawable.compose_multiplatform), null)
                    Text("Compose: $greeting")
                }
            }
        }
    }
}
  
```

the "Column" function is a composable function that takes a lambda in which
you can define child widgets. Column then lays out these widgets vertically 
in a column. Each widget in Columns trailing lambda is also composable. 

JetPack only draws a widget or runs a composable function when there are
its paremeters. If there is no change it is not run.

# Usefull links
Here a collection of usefull links that go into more detail. I recomend the KMP
and KMP compose resources the most.
- [KMP shared UI and data logic guide](https://www.jetbrains.com/help/kotlin-multiplatform-dev/compose-multiplatform-create-first-app.html)
- [KMP Compose guide](https://www.jetbrains.com/help/kotlin-multiplatform-dev/compose-multiplatform-and-jetpack-compose.html)
- [Getting started with kotlin](https://kotlinlang.org/docs/getting-started.html)
- [Gradle guide](https://docs.gradle.org/current/userguide/userguide.html)

